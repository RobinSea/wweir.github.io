---
title: "Golang 项目组织形式的演进"
date: 2018-10-25T10:38:54+08:00
lastmod: 2018-10-26T14:51:58+08:00
draft: false
tags:
- golang
- git
categories:
- dev
---

# 包管理与项目组织形式的历史

很多从其它语言转 golang 的程序员都会对 `GOPATH` 这个设定感到困惑，为什么其它语言不要求把所有代码放在同一个目录，golang 就有这样一个奇怪的要求。

根据之前的了解，这是由于几位来自 google 的主要缔造者造成的。google 把所有的代码放在一个大仓库里，很好用，于是 golang 就也设计成了这种模式，把所有代码都放在一起，很好用。

## 项目代码直接放 git 目录

这样也就形成了我们最朴素，在 github 上也最常见的项目组织形式，直接把包放在 git 目录中，推上 github 等一众代码托管平台。这里最重要的，就是所有包都是以远程包的形式来使用。

但是，这也有一个大大的问题，就是所有依赖包都在远程，如果我们依赖的某个第三方库删掉或者进行了不兼容的更新，就麻烦了。同时，功夫网也给这种项目组织形式造成了很多麻烦。

## GOPATH 放 git 目录

于是 golang 提供了多 `GOPATH` 的支持，这也形成了 golang 支持 vendor（1.5，1.6） 之前主要的项目结构组织。具体来说，就是把整个 `GOPATH` 都放在 git 目录中，这样所有依赖的代码就都有备份了，只要 git 目录在，我们就一定可以进行正常开发和编译。

但是，这种组织形式是真的丑，丑出天际。各种依赖库都在本地有完整的备份，这也就包括了大量我们不需要的代码。最难受的是，各依赖库 `.git` 目录该怎么处理，这目录删掉如果删掉，就没法升级依赖库了。那么，是选择`git submodule` 、`git subtree` 还是强行把 `.git` 目录下的文件当成普通文件加到项目中？

## vendor

针对前面的问题，golang 在 1.5、1.6 的时候，又给出了新的解决方案，就是 vendor 目录的支持。发展到这里，整个项目看起来终于不那么难受了，当然，还远远算不上好。此时，我们只要把项目代码中加入 vendor 目录，并把所有依赖的代码放在 vendor 目录下就可以了。而把依赖代码放入 vendor 目录的工作，可以通过工具自动化实现，其中使用最广泛的工具是 `glide` 和 `dep`，其中 `glide` 出现较早，`dep` 作为官方推出的工具，出现较晚。这些依赖管理工具都有自己推导版本依赖的功能，自动选出适合自己项目的依赖库版本。

vendor 虽说已经比较好用了，相比其它语言的包管理以及代码组织，还是算不上优秀。比如相同的库的代码，在多个项目中需要保存多份。这占用了一些的磁盘空间，并且编译器无法重复利用编译的缓存文件，加长了编译时间。还有一个很重要的点就是我们的代码始终还是要放在 `GOPATH` 里面，相比其它语言，这始终是个很奇怪的事情。

## Go modules

Go mod 是官方最新推出的依赖管理方案，这个方案很大程度上解决了之前的问题。项目代码可以放在任意目录，依赖库统一保存在 `$GOPATH/pkg/mod` 底下，可以轻松做到避免重复代码、编译缓存。基本和其它语言一些优秀的包管理策略相差不大。同时，其附带的版本管理方案，也还不错。这样，我们就可以只把我们自己的代码干干净净地放在 git 目录中了。

当然，也有缺点。首先，配置文件使用自定义的语法，就是一件很难受的事情，虽然语法不复杂，但想对配置文件做一些深度一些的自动化操作，就很麻烦了。其次，到底还是没有避开 `GOPATH` 这个概念，默认 `GOPATH` 的位置比较碍眼，如果想修改对应的位置，就不得不去了解这个概念。还有一个问题，也全怪在 golang 身上，golang 把全网当做包的远程源，这就难免有一些包被删、被功夫网屏蔽。

## 回望与希冀

哈哈哈，从头再捋一遍，不襟感觉天道有轮回，开头就描述的某些严重问题，中间阶段被解决了，然而到最后又冒出来了。这实际是由于没有包的中心下载仓库导致的，没有中心仓库，就无法保证所有包都能方便地下载与使用，同时没有审核之类的东西，各个包的质量也难以保证。当然，这么做的好处也是有的，就是我们自己发布包非常方便，五花八门的包也会多些。

对比最朴素的 go get 与最后的 go mod 方案，可以发现，真正解决的主要有三个问题：

1. 一定程度上干掉了 `GOPATH`
2. 包的版本推导与管理
3. 第三方包下载到本地的形式

依然存在的问题：

1. `GOPATH` 仍然是一个无法抹去的概念
2. 各依赖库依然存在被删除、被屏蔽等问题

在可预见的未来，还会存在以下的严重问题：

1. 由于之前 golang 一直没突出语义化版本，导致目前大量库没版本(0.0.0)，或者长期使用初期版本(0.0.1)不作更新。这就导致各工具在分析语义化版本的时候，会出问题，特别第二种情况，后果更加严重。可以想象这样一个场景，项目使用了一个第三方库，开发什么的都很活跃，质量也很好，但仓库存在且只存在一个两年前的 0.0.1 的 tag，版本推导就没法用了，只能手动冻结使用的 commit 号。
2. 由于没有中心化的依赖库下载源，导致大量依赖库质量不高的库被使用，影响 golang 整个生态的发展速度。

## 随记：快速将现有项目依赖管理转换为 go modules

1. 在当前项目目录中执行 `GO111MODULE=on go mod init github.com/user/repo`
2. go list
3. `GO111MODULE=on go mod tidy`
4. 需要使用 vendor 目录的话，执行 `GO111MODULE=on go mod vendor`
5. git 提交当前代码
6. 在 `GOPATH` 以外的地方下载当前项目，将默认开启 go mod 相关功能

### 存在问题

当 go modules 启用的时候，编译不使用 vendor 底下的内容。在 vendor 的时代，golang 编译基本不用下载任何包，现在的话，需要下载包，这就意味着 ci 的 runner 必须具备代理，一朝回到解放前的既视感。不使用代理的话，就必须在项目目录的 `go.mod` 包中写出所有用到的包的替代地址，精确到版本。

另外一个有意思的点就是，如果一个项目用到了某个已经使用 module 进行版本管理的第三方包，go build 会下载该第三方包的 `go.mod` 文件中所有的包，不管是否在项目代码的依赖链中。但不会使用该第三方包 `go.mod` 文件中的地址替换规则。